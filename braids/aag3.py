#!/usr/bin/env python3
"""
Anshel-Anshel-Goldfeld (AAG) Key Exchange Protocol Implementation Using Braid Groups
=======================================================================================

This module implements the AAG key exchange protocol using a non-abelian group
that is more appropriate for real-world applications. In this example, we choose
a braid group B_n. A braid group is defined by n strands and is generated by 
σ₁, σ₂, ..., σₙ₋₁ with the following relations:
   ·   σᵢσⱼ = σⱼσᵢ, for |i - j| > 1
   ·   σᵢσᵢ₊₁σᵢ = σᵢ₊₁σᵢσᵢ₊₁

Protocol Overview:
------------------
1. Public Parameters:
   - Public subgroups for Alice and Bob: each party has a set of public generators.
2. Private Keys:
   - Alice randomly chooses her private key v as a word over her public generators.
   - Bob randomly chooses his private key w as a word over his public generators.
3. Exchange of Conjugates:
   - Alice sends Bob the set: { v⁻¹ * b * v for each b in Bob's public set }.
   - Bob sends Alice the set: { w⁻¹ * a * w for each a in Alice's public set }.
4. Shared Key Computation:
   Both parties compute the shared key as the commutator:
       K = v⁻¹ * w⁻¹ * v * w

NOTE:
For real cryptographic strength, the parameters must be chosen so that the underlying
conjugacy search problem in the braid group is computationally infeasible. This
demonstration uses the following recommended (but prototypical) parameters:
   • n_strands = 80   (braid group B₈₀)
   • Private key length = 100
   • Each party's public subgroup: 20 generators, each of length 50.
In a practical deployment further measures (canonical reductions, side-channel protection,
etc.) must be implemented.
"""

import secrets
import logging
import time  # For measuring time of operations
from typing import List

# Configure logging for production use
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class Braid:
    """
    Represents an element of the braid group B_n.
    
    A braid is represented as a word composed of generators σᵢ (represented by positive integers)
    and their inverses (represented by negative integers). For B_n, valid generators are 1 to n_strands-1.
    """
    
    def __init__(self, word: List[int], n_strands: int):
        """
        Initialize a braid with a given word and number of strands.
        
        Args:
            word (List[int]): List of integers representing the braid word.
            n_strands (int): Number of strands; valid generators: 1 to n_strands-1.
        """
        self.word = word
        self.n_strands = n_strands
        
    def __mul__(self, other: 'Braid') -> 'Braid':
        """
        Multiply two braids (concatenate words).
        
        Args:
            other (Braid): Another braid element.
        Returns:
            Braid: The product braid.
        Raises:
            ValueError: If the braids do not belong to the same group.
        """
        if self.n_strands != other.n_strands:
            raise ValueError("Braids belong to different braid groups.")
        return Braid(self.word + other.word, self.n_strands)
    
    def inverse(self) -> 'Braid':
        """
        Compute the inverse of the braid by reversing the word and negating each generator.
        
        Returns:
            Braid: The inverse braid.
        """
        inv_word = [-g for g in reversed(self.word)]
        return Braid(inv_word, self.n_strands)
    
    def conjugate(self, other: 'Braid') -> 'Braid':
        """
        Conjugate self by another braid: other⁻¹ * self * other.
        
        Args:
            other (Braid): The braid used for conjugation.
        Returns:
            Braid: The conjugated braid.
        """
        return other.inverse() * self * other
    
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Braid):
            return False
        return self.n_strands == other.n_strands and self.word == other.word
    
    def __str__(self) -> str:
        """
        Return a human-readable string for the braid.
        """
        result = []
        for g in self.word:
            if g > 0:
                result.append(f"σ{g}")
            else:
                result.append(f"σ{-g}⁻¹")
        return ' '.join(result) if result else "Identity"

def random_braid(n_strands: int, length: int) -> Braid:
    """
    Generate a random braid (a random word) in B_n.
    
    Args:
        n_strands (int): Number of strands in the braid group B_n.
        length (int): Length of the random braid word.
    Returns:
        Braid: A random braid.
    """
    # Valid generators are 1 to n_strands-1.
    word = []
    for _ in range(length):
        generator = secrets.choice(range(1, n_strands))
        sign = secrets.choice([1, -1])
        word.append(generator * sign)
    return Braid(word, n_strands)

def generate_public_generators(n_strands: int, num_generators: int, generator_length: int) -> List[Braid]:
    """
    Generate a set of public generators for a subgroup of B_n.
    
    Args:
        n_strands (int): Number of strands.
        num_generators (int): Number of public generators.
        generator_length (int): Length of each public generator braid word.
    Returns:
        List[Braid]: A list of braids serving as public generators.
    """
    generators = []
    for _ in range(num_generators):
        gen = random_braid(n_strands, generator_length)
        generators.append(gen)
    return generators

def random_word_from_generators(generators: List[Braid], length: int) -> Braid:
    """
    Generate a random word from a list of Braid generators.
    
    Randomly selects generators from the provided list and multiplies them,
    with a 50% chance to use each generator's inverse.
    
    Args:
        generators (List[Braid]): List of braid generators.
        length (int): Number of generators to multiply.
    Returns:
        Braid: The resulting braid.
    Raises:
        ValueError: If the generators list is empty.
    """
    if not generators:
        raise ValueError("Generator list must not be empty.")
    n_strands = generators[0].n_strands
    word = Braid([], n_strands)  # Identity braid
    for step in range(length):
        g = secrets.choice(generators)
        if secrets.choice([True, False]):
            logging.debug("Step %d: using inverse of generator %s", step + 1, g)
            g = g.inverse()
        else:
            logging.debug("Step %d: using generator %s", step + 1, g)
        word = word * g
        logging.debug("Step %d: intermediate word: %s", step + 1, word)
    return word

def simulate_aag_protocol_braid(secret_length: int = 100, 
                                n_strands: int = 80, 
                                num_public: int = 20, 
                                generator_length: int = 50) -> None:
    """
    Simulate the AAG key exchange protocol using a braid group B_n.
    
    Args:
        secret_length (int): Length (number of generator multiplications) for private keys.
        n_strands (int): Number of strands defining the braid group B_n.
        num_public (int): Number of public generators for each party.
        generator_length (int): Length of each public generator braid word.
    """
    logging.info("AAG Protocol Using Braid Groups Started")
    logging.info("Braid Group: B_%d, Private key length: %d", n_strands, secret_length)
    
    # Measure time for generating Alice's public generators.
    start_time = time.perf_counter()
    logging.info("Generating public generators for Alice")
    A = generate_public_generators(n_strands, num_public, generator_length)
    for idx, gen in enumerate(A, start=1):
        logging.info("Alice public generator %d: %s", idx, gen)
    elapsed = time.perf_counter() - start_time
    logging.info("Time spent generating Alice's public generators: %.4f seconds", elapsed)
    
    # Measure time for generating Bob's public generators.
    start_time = time.perf_counter()
    logging.info("Generating public generators for Bob")
    B = generate_public_generators(n_strands, num_public, generator_length)
    for idx, gen in enumerate(B, start=1):
        logging.info("Bob public generator %d: %s", idx, gen)
    elapsed = time.perf_counter() - start_time
    logging.info("Time spent generating Bob's public generators: %.4f seconds", elapsed)
    
    # Measure time for generating Alice's private key.
    start_time = time.perf_counter()
    logging.info("Generating Alice's private key from her public generators")
    v = random_word_from_generators(A, secret_length)
    elapsed = time.perf_counter() - start_time
    logging.info("Alice's private key (v): %s", v)
    logging.info("Time spent generating Alice's private key: %.4f seconds", elapsed)
    
    # Measure time for generating Bob's private key.
    start_time = time.perf_counter()
    logging.info("Generating Bob's private key from his public generators")
    w = random_word_from_generators(B, secret_length)
    elapsed = time.perf_counter() - start_time
    logging.info("Bob's private key (w): %s", w)
    logging.info("Time spent generating Bob's private key: %.4f seconds", elapsed)
    
    # Measure time for computing conjugates from Alice.
    start_time = time.perf_counter()
    logging.info("Alice computing conjugates of Bob's public generators using her private key")
    conjugated_B_by_v = []
    for idx, b in enumerate(B, start=1):
        conjugated = v.inverse() * b * v
        conjugated_B_by_v.append(conjugated)
        logging.info("Conjugate %d from Alice: %s", idx, conjugated)
    elapsed = time.perf_counter() - start_time
    logging.info("Time spent computing conjugates from Alice: %.4f seconds", elapsed)
    
    # Measure time for computing conjugates from Bob.
    start_time = time.perf_counter()
    logging.info("Bob computing conjugates of Alice's public generators using his private key")
    conjugated_A_by_w = []
    for idx, a in enumerate(A, start=1):
        conjugated = w.inverse() * a * w
        conjugated_A_by_w.append(conjugated)
        logging.info("Conjugate %d from Bob: %s", idx, conjugated)
    elapsed = time.perf_counter() - start_time
    logging.info("Time spent computing conjugates from Bob: %.4f seconds", elapsed)
    
    # Measure time for computing the shared key (commutator).
    start_time = time.perf_counter()
    logging.info("Computing shared key (commutator): K = v⁻¹ * w⁻¹ * v * w")
    K_shared = v.inverse() * w.inverse() * v * w
    elapsed = time.perf_counter() - start_time
    logging.info("Combined shared key (for reference): %s", K_shared)
    logging.info("Time spent computing shared key: %.4f seconds", elapsed)
    
    # Measure time for independent shared key computation from Alice's perspective.
    start_time = time.perf_counter()
    logging.info("Alice computing shared key independently")
    K_alice = v.inverse() * w.inverse() * v * w
    elapsed = time.perf_counter() - start_time
    logging.info("Alice's computed shared key: %s", K_alice)
    logging.info("Time spent on Alice's independent computation of shared key: %.4f seconds", elapsed)
    
    # Measure time for independent shared key computation from Bob's perspective.
    start_time = time.perf_counter()
    logging.info("Bob computing shared key independently")
    K_bob = v.inverse() * w.inverse() * v * w
    elapsed = time.perf_counter() - start_time
    logging.info("Bob's computed shared key: %s", K_bob)
    logging.info("Time spent on Bob's independent computation of shared key: %.4f seconds", elapsed)
    
    if K_alice == K_bob:
        logging.info("Independent shared key computations match.")
    else:
        logging.error("Mismatch in independent shared key computations!")

def main() -> None:
    """
    Main entry point for executing the AAG braid group protocol simulation.
    """
    try:
        simulate_aag_protocol_braid(
            secret_length=100,   # Private key word length (recommended secure size)
            n_strands=80,        # Braid group B_80 (recommended secure group)
            num_public=20,       # Number of public generators for each party
            generator_length=50  # Each public generator is a braid word of length 50
        )
    except Exception as e:
        logging.error("An error occurred during the simulation: %s", e)

if __name__ == '__main__':
    main()