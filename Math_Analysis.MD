# Mathematical Analysis of the NTT-Based Key Exchange Protocol

This document formally analyzes an NTT‑based key exchange protocol that is a sequence‑based analogue of the traditional Diffie–Hellman (DH) key exchange. The protocol leverages the efficiency of the Number Theoretic Transform (NTT) for cyclic convolution operations. We describe the protocol, prove its correctness, analyze its security under standard assumptions, and discuss potential pitfalls and practical recommendations.

---

## 1. Protocol Description

Let the following parameters be given:
- **p**: A prime modulus. In practice, p must be very large (e.g. ≥ 2048 bits) to resist factoring and number field sieve attacks. Moreover, p must satisfy  
  p ≡ 1 (mod n)  
  so that an n‑th root of unity exists in GF(p). (While safe primes, p = 2q + 1 with q prime, are common in DH protocols, one must additionally ensure that n divides p − 1.)
- **n**: The length of the sequences.
- **ω**: A primitive n‑th root of unity in GF(p).
- **G**: A public sequence in GF(p)ⁿ chosen such that its NTT, F = NTT(G), has no zero components and every component is an element of a subgroup with large multiplicative order.
- **a, b**: Secret exponents chosen uniformly at random from a sufficiently large range.

**Definition (Convolution Power):**  
We denote by G^[x] the "convolution‑power" of G, defined as the repeated cyclic convolution of G with itself x times. Thanks to the NTT, we have the following isomorphism:
  NTT(G^[x]) = (NTT(G))^x  
where exponentiation on the right is computed element‑wise modulo p.

**Key Exchange Steps:**
1. **Alice** computes Yₐ = G^[a] and sends Yₐ to Bob.
2. **Bob** computes Y_b = G^[b] and sends Y_b to Alice.
3. **Key Derivation:**  
   - Alice computes the shared key: Kₐ = (Y_b)^[a] = G^[ab].  
   - Bob computes the shared key: K_b = (Yₐ)^[b] = G^[ab].
4. Optionally, the shared key may be passed through a hash function for key derivation (to hide any residual structure).

In the frequency domain, these steps are implemented via the NTT and its inverse (INTT):
  K = INTT((NTT(G))^(ab)).

---

## 2. Correctness Proof

### 2.1. The NTT and the Convolution Theorem

The Number Theoretic Transform (NTT) for sequences over GF(p) satisfies the convolution theorem:
  NTT(A * B) = NTT(A) ⊙ NTT(B),
where:
- "*" denotes cyclic convolution,
- "⊙" denotes element‑wise multiplication,
- A and B are sequences of length n.

Thus, defining convolution‑exponentiation by repeated convolution, we obtain:
  NTT(G^[x]) = (NTT(G))^x  (for any nonnegative integer x).

### 2.2. Derivation of the Shared Key

Consider the following:
- Bob sends Y_b = G^[b].  
  Taking the NTT gives: NTT(Y_b) = (NTT(G))^b.
- Alice raises Y_b to the power a using convolution‑exponentiation:
  - In the frequency domain, this yields  
    NTT((Y_b)^[a]) = (NTT(Y_b))^a = ((NTT(G))^b)^a = (NTT(G))^(ab).
- Conversely, Bob computes (Yₐ)^[b] with the same result in the frequency domain.

Finally, applying the INTT yields the shared key:
  K = INTT((NTT(G))^(ab)) = G^[ab].

Thus, both parties derive the identical key, proving protocol correctness.

---

## 3. Security Analysis

### 3.1. Underlying Hard Problem

The security of the protocol relies on a variant of the Computational Diffie–Hellman (CDH) assumption. In conventional DH, one assumes that given gᵃ and gᵇ it is intractable to compute g^(ab) in a cyclic group. Here, by switching to the convolution setting:
- In the frequency domain, the public data (the exchanged values) are (NTT(G))^a and (NTT(G))^b.
- For each coordinate k (i.e., for F[k] = (NTT(G))[k]), the adversary must compute F[k]^(ab) knowing F[k]^a and F[k]^b.

Assuming that discrete logarithm computations (and hence the CDH problem) in the subgroup generated by F[k] are hard for each k, breaking the protocol reduces to solving n parallel CDH problems.

### 3.2. Parameter Requirements

For the security reduction to hold, we require:
- **Prime Modulus p:**  
  - p must be large (e.g. ≥2048 bits).  
  - p should satisfy p ≡ 1 (mod n) for a proper NTT.  
  - (Note: While safe primes p = 2q + 1 offer advantages, one must ensure that n divides p − 1.)
- **Primitive Root ω:**  
  - ω must be a valid primitive n‑th root of unity in GF(p) to guarantee the invertibility of the NTT.
- **Public Sequence G:**  
  - G should be chosen randomly so that F = NTT(G) has no zero entries and each F[k] belongs to a subgroup of large order.  
  - This prevents trivial attacks in any coordinate (for instance, when F[k] is 1 or –1).

### 3.3. Potential Weaknesses and Mitigations

- **Small‑Order Components:**  
  If any coordinate F[k] has a small multiplicative order, then the effective exponent (and hence the security) in that coordinate is weakened.  
  *Mitigation:* Verify that each F[k] has large order by appropriate choice of p and random selection of G.

- **Structured or Low‑Entropy G:**  
  A non‑random or structured public sequence G can lead to predictable NTT components and potential weaknesses.  
  *Mitigation:* Generate G using a cryptographically secure random process and validate that NTT(G) shows no exploitable structure.

- **Residual Key Structure:**  
  The derived key K = G^[ab] may leak some structure inherent to the convolution process.  
  *Mitigation:* Use a cryptographic hash on K prior to its use as a symmetric key.

---

## 4. Robustness and Practical Considerations

- **Parameter Verification:**  
  All parameters (p, n, ω, and G) must be chosen to ensure that the discrete logarithm problem is hard in every coordinate.  
- **Computational Efficiency:**  
  Thanks to the fast NTT and INTT algorithms, the operations run in O(n log n) time, making the protocol efficient even for large n.
- **Authenticated Exchange:**  
  While the analysis focuses on mathematical security, practical deployment should also include authentication mechanisms to thwart man‑in‑the‑middle attacks.

---

## 5. Conclusion and Recommendations

In summary, the NTT‑based key exchange protocol offers a mathematically secure alternative to classical Diffie–Hellman. Under the assumption that CDH is intractable in each frequency component of GF(p), and provided that all parameters (p, n, ω, and G) are chosen appropriately, the protocol is correct and secure.

**Recommendations:**
- Choose p to be a large prime satisfying p ≡ 1 (mod n) and with no small factors other than those allowed by design.
- Ensure ω is a proper primitive n‑th root of unity in GF(p).
- Generate G randomly, and verify that NTT(G) contains no zero or low‑order elements.
- Hash the final key K to eliminate any exploitable structure before further use.
- Incorporate message authentication to protect against active attacks.

This rigorous analysis clarifies the underpinning assumptions, proofs, and necessary conditions for a robust and efficient NTT‑based key exchange. 
